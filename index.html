<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crowe Hourly Charge Reconciliation</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f7f6f2;
      --bg-accent: #eef0f4;
      --card: #ffffff;
      --text: #1c232b;
      --muted: #5b6775;
      --border: #d8dfe7;
      --accent: #1f5f8b;
      --accent-2: #0f4c5c;
      --success: #1b7f5f;
      --warning: #b86b00;
      --danger: #a61b1b;
      --shadow: 0 18px 35px rgba(18, 38, 63, 0.12);
      --pill-bg: #eef3f8;
      --pill-text: #1d384e;
      --table-header: #f1f4f9;
      --table-row: #f9fbfe;
    }

    body.dark {
      color-scheme: dark;
      --bg: #0e1116;
      --bg-accent: #1b212b;
      --card: #141b24;
      --text: #e7edf4;
      --muted: #a9b4c2;
      --border: #263243;
      --accent: #6fb1e6;
      --accent-2: #9ad1c7;
      --success: #49c192;
      --warning: #f0a23b;
      --danger: #ef6b6b;
      --shadow: 0 18px 35px rgba(3, 8, 17, 0.35);
      --pill-bg: #1c2633;
      --pill-text: #c7d9ee;
      --table-header: #1c2633;
      --table-row: #141b24;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Calibri, "Segoe UI", Arial, sans-serif;
      background:
        radial-gradient(circle at top right, rgba(31, 95, 139, 0.1), transparent 55%),
        radial-gradient(circle at 10% 20%, rgba(15, 76, 92, 0.08), transparent 45%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: clamp(18px, 3vw, 36px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 2vw, 28px);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 20px;
      flex-wrap: wrap;
    }

    header h1 {
      margin: 0;
      font-size: clamp(24px, 3vw, 34px);
      letter-spacing: 0.2px;
    }

    header p {
      margin: 6px 0 0;
      color: var(--muted);
      max-width: 760px;
      line-height: 1.5;
    }

    .toggle-btn {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding: 8px 14px;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: var(--shadow);
      font-weight: 600;
      transition: transform 0.2s ease, border 0.2s ease;
    }

    .toggle-btn:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(14px, 2vw, 22px);
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: clamp(16px, 2vw, 24px);
      box-shadow: var(--shadow);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: clamp(18px, 2vw, 22px);
    }

    .card p {
      margin: 8px 0;
      color: var(--muted);
      line-height: 1.5;
    }

    .dropzone {
      border: 2px dashed var(--border);
      border-radius: 18px;
      padding: clamp(16px, 2vw, 22px);
      text-align: center;
      background: var(--bg-accent);
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .dropzone.dragover {
      border-color: var(--accent);
      background: rgba(31, 95, 139, 0.08);
    }

    .dropzone input {
      margin-top: 12px;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      background: var(--pill-bg);
      color: var(--pill-text);
    }

    .status.success {
      background: rgba(27, 127, 95, 0.16);
      color: var(--success);
    }

    .status.warning {
      background: rgba(184, 107, 0, 0.16);
      color: var(--warning);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: clamp(6px, 1vw, 10px) clamp(12px, 2vw, 18px);
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-weight: 600;
      font-size: clamp(12px, 1.1vw, 14px);
    }

    .pill strong {
      font-weight: 700;
    }

    .summary-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 12px 0;
    }

    .form-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label {
      font-weight: 600;
      color: var(--text);
    }

    select, input[type="date"], input[type="password"], input[type="text"] {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 8px 10px;
      font-family: inherit;
      font-size: 14px;
      background: var(--card);
      color: var(--text);
      min-width: 160px;
    }

    button {
      border: none;
      background: var(--accent);
      color: white;
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow);
    }

    button.secondary {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      font-size: 13px;
    }

    th, td {
      border-bottom: 1px solid var(--border);
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }

    th {
      background: var(--table-header);
      font-weight: 700;
    }

    tr:nth-child(even) td {
      background: var(--table-row);
    }

    .muted {
      color: var(--muted);
    }

    .alert {
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(166, 27, 27, 0.08);
      color: var(--danger);
      font-weight: 600;
      margin-top: 12px;
    }

    .success {
      color: var(--success);
      font-weight: 600;
    }

    .attestation {
      margin-top: 16px;
      padding: 14px;
      border-radius: 14px;
      border: 1px dashed var(--border);
      background: var(--bg-accent);
    }

    .attestation label {
      font-weight: 500;
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      background: rgba(31, 95, 139, 0.12);
      color: var(--accent);
    }

    .hidden {
      display: none !important;
    }

    .footnote {
      font-size: 12px;
      color: var(--muted);
    }

    .landing-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 18px;
      margin-top: 14px;
    }

    .choice-card {
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      background: var(--card);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .choice-card h3 {
      margin: 0;
    }

    .choice-card button {
      width: 100%;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Crowe Hourly Charge Reconciliation</h1>
        <p>Choose your role to continue. Admins publish the reconciliation package and review attestations. Employees review their entries and submit attestations.</p>
      </div>
      <button class="toggle-btn" id="themeToggle">Enable Dark Mode</button>
    </header>

    <section class="card" id="landingView">
      <h2>Welcome</h2>
      <p>Select your path below.</p>
      <div class="landing-grid">
        <div class="choice-card">
          <h3>Admin</h3>
          <p>Upload workbooks, publish the employee package, and review attestation status.</p>
          <button id="goAdminBtn">Enter Admin</button>
        </div>
        <div class="choice-card">
          <h3>Employee</h3>
          <p>Review your reconciliation and submit your attestation.</p>
          <button id="goEmployeeBtn">Enter Employee</button>
        </div>
      </div>
    </section>

    <section id="adminView" class="hidden">
      <div class="form-row" style="margin-bottom: 12px;">
        <button class="secondary" id="adminBackBtn">Back to Landing</button>
      </div>

      <section class="card" id="adminGate">
        <h2>Admin Access</h2>
        <p>Enter the local admin passcode to unlock upload, package, and reporting tools.</p>
        <div class="form-row">
          <input type="password" id="admin-passcode" placeholder="Passcode" />
          <button id="admin-unlockBtn">Unlock</button>
          <span class="muted" id="admin-unlockStatus"></span>
        </div>
      </section>

      <div id="adminContent" class="hidden">
        <section class="grid">
          <div class="card">
            <h2>Data Upload</h2>
            <div class="dropzone" id="admin-assignmentsDrop">
              <div class="pill">Assignments Workbook</div>
              <p>Drag and drop `Assignments.xlsx` here.</p>
              <input type="file" id="admin-assignmentsFile" accept=".xlsx,.xls" />
              <div class="status" id="admin-assignmentsStatus">Waiting for file</div>
            </div>
            <div style="height: 14px;"></div>
            <div class="dropzone" id="admin-timeDetailDrop">
              <div class="pill">Time Detail Workbook</div>
              <p>Drag and drop the Project Summary / Time Detail workbook here.</p>
              <input type="file" id="admin-timeDetailFile" accept=".xlsx,.xls" />
              <div class="status" id="admin-timeDetailStatus">Waiting for file</div>
            </div>
            <p class="footnote">Headers can appear below row 1; the tool scans for the right columns automatically.</p>
          </div>

          <div class="card">
            <h2>Date Range</h2>
            <p>Exclusive start and end dates. Example: Start 01/01, End 02/01 captures January only.</p>
            <div class="form-row">
              <label for="admin-startDate">Start</label>
              <input type="date" id="admin-startDate" />
              <label for="admin-endDate">End</label>
              <input type="date" id="admin-endDate" />
            </div>
            <p class="muted">Dates filter the Time Detail “Date” column. Engagement mismatches are evaluated within the selected range.</p>
          </div>
        </section>

        <section class="card" id="admin-packageSection">
          <h2>Employee Package</h2>
          <p>After loading the workbooks and date range, publish the employee package to the server.</p>
          <div class="summary-row" id="admin-packageSummary"></div>
          <div class="form-row">
            <button id="admin-downloadPackageBtn">Publish Package</button>
            <span class="status" id="admin-packageStatus">Not Ready</span>
          </div>
          <p class="footnote">The package contains only the incorrect entries and missing memos needed for each employee.</p>
        </section>

        <section class="card" id="admin-attestationSection">
          <h2>Attestation Intake</h2>
          <p>Status updates are stored automatically when employees view or attest. Refresh to see the latest status.</p>
          <div class="form-row">
            <button class="secondary" id="admin-refreshAttestationsBtn">Refresh Status</button>
            <span class="muted" id="admin-attestationStatus"></span>
          </div>
          <div class="summary-row" id="admin-attestationSummary"></div>
          <div id="admin-attestationTable"></div>
        </section>

        <section class="card" id="admin-outputSection">
          <h2>Admin Output</h2>
          <div class="summary-row" id="admin-summary"></div>
          <div class="form-row">
            <button id="admin-exportBtn">Download Admin Excel Report</button>
          </div>
          <div id="admin-output"></div>
        </section>
      </div>
    </section>

    <section id="employeeView" class="hidden">
      <div class="form-row" style="margin-bottom: 12px;">
        <button class="secondary" id="empBackBtn">Back to Landing</button>
      </div>

      <section class="card" id="emp-packageSection">
        <h2>Latest Package</h2>
        <p>The latest reconciliation package loads automatically from the server.</p>
        <div class="form-row">
          <span class="status" id="emp-packageStatus">Loading latest package...</span>
        </div>
        <div class="summary-row" id="emp-packageInfo"></div>
      </section>

      <section class="card" id="emp-employeeSection">
        <h2>Employee View</h2>
        <div class="form-row">
          <label for="emp-employeeSelect">Employee</label>
          <select id="emp-employeeSelect">
            <option value="">Employees will appear once the package loads</option>
          </select>
          <span class="badge" id="emp-employeeStatus">Not Ready</span>
        </div>
        <div class="summary-row" id="emp-employeeSummary"></div>
        <div id="emp-employeeOutput"></div>
        <div class="attestation hidden" id="emp-attestationPanel">
          <div id="emp-attestationMessage" class="muted"></div>
          <div class="form-row" style="margin-top: 10px;">
            <input type="checkbox" id="emp-attestationCheck" />
            <label for="emp-attestationCheck">I confirm this reconciliation is accurate for the selected period.</label>
          </div>
          <div class="form-row" style="margin-top: 10px;">
            <button id="emp-attestBtn">Submit Attestation</button>
            <span class="muted" id="emp-attestationStatus"></span>
          </div>
          <p class="footnote">Your view and attestation are saved automatically.</p>
        </div>
      </section>
    </section>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    const landingView = document.getElementById("landingView");
    const adminView = document.getElementById("adminView");
    const employeeView = document.getElementById("employeeView");

    function showView(view) {
      landingView.classList.add("hidden");
      adminView.classList.add("hidden");
      employeeView.classList.add("hidden");
      if (view === "admin") adminView.classList.remove("hidden");
      if (view === "employee") employeeView.classList.remove("hidden");
      if (view === "landing") landingView.classList.remove("hidden");
    }

    document.getElementById("goAdminBtn").addEventListener("click", () => showView("admin"));
    document.getElementById("goEmployeeBtn").addEventListener("click", () => showView("employee"));
    document.getElementById("adminBackBtn").addEventListener("click", () => showView("landing"));
    document.getElementById("empBackBtn").addEventListener("click", () => showView("landing"));

    const themeToggle = document.getElementById("themeToggle");
    themeToggle.addEventListener("click", () => {
      document.body.classList.toggle("dark");
      const dark = document.body.classList.contains("dark");
      themeToggle.textContent = dark ? "Enable Light Mode" : "Enable Dark Mode";
      localStorage.setItem("crowe_theme", dark ? "dark" : "light");
    });

    (function initTheme() {
      const stored = localStorage.getItem("crowe_theme");
      if (stored === "dark") {
        document.body.classList.add("dark");
        themeToggle.textContent = "Enable Light Mode";
      }
    })();

    (function adminApp() {
      const state = {
        assignments: [],
        assignmentsById: new Map(),
        assignmentsByWorkerId: new Map(),
        assignmentsByName: new Map(),
        timeEntries: [],
        summaries: null,
        attestationEvents: [],
        attestationStatusRows: [],
        statusMap: new Map(),
        packageId: ""
      };

      const ADMIN_PASSCODE = "admin1";

      const els = {
        assignmentsStatus: document.getElementById("admin-assignmentsStatus"),
        timeDetailStatus: document.getElementById("admin-timeDetailStatus"),
        startDate: document.getElementById("admin-startDate"),
        endDate: document.getElementById("admin-endDate"),
        packageSummary: document.getElementById("admin-packageSummary"),
        packageStatus: document.getElementById("admin-packageStatus"),
        downloadPackageBtn: document.getElementById("admin-downloadPackageBtn"),
        refreshAttestationsBtn: document.getElementById("admin-refreshAttestationsBtn"),
        attestationStatus: document.getElementById("admin-attestationStatus"),
        attestationSummary: document.getElementById("admin-attestationSummary"),
        attestationTable: document.getElementById("admin-attestationTable"),
        adminSummary: document.getElementById("admin-summary"),
        adminOutput: document.getElementById("admin-output"),
        exportBtn: document.getElementById("admin-exportBtn"),
        adminPasscode: document.getElementById("admin-passcode"),
        adminUnlockBtn: document.getElementById("admin-unlockBtn"),
        adminUnlockStatus: document.getElementById("admin-unlockStatus"),
        adminContent: document.getElementById("adminContent"),
        assignmentsFile: document.getElementById("admin-assignmentsFile"),
        timeDetailFile: document.getElementById("admin-timeDetailFile")
      };

      function normalizeHeader(value) {
        return String(value || "").toLowerCase().replace(/[^a-z0-9]/g, "");
      }

      const HEADER_ALIASES = {
        resourceName: ["resourcename", "resource", "employeename", "workername", "worker", "name"],
        serviceLine: ["serviceline", "service line", "service_line"].map(normalizeHeader),
        workerId: ["workerid", "resourceid", "employeeid", "worker id", "resource id", "employee id"].map(normalizeHeader),
        taskDesc: ["taskdesc", "tascdesc", "taskdescription", "tascdescription"].map(normalizeHeader),
        date: ["date", "workdate", "transactiondate", "timeentrydate"].map(normalizeHeader),
        memo: ["memo", "notes", "comment"].map(normalizeHeader),
        hours: ["hours", "hrs"].map(normalizeHeader),
        project: ["project", "projectname"].map(normalizeHeader)
      };

      function buildHeaderLookup() {
        const lookup = {};
        Object.entries(HEADER_ALIASES).forEach(([key, aliases]) => {
          aliases.forEach((alias) => {
            lookup[alias] = key;
          });
        });
        return lookup;
      }

      const HEADER_LOOKUP = buildHeaderLookup();

      function normalizeText(value) {
        return String(value || "").trim().replace(/\s+/g, " ").toLowerCase();
      }

      function normalizeWorkerId(value) {
        if (value === undefined || value === null) return "";
        const digits = String(value).replace(/\D/g, "");
        if (!digits) return "";
        return digits.replace(/^0+/, "") || digits;
      }

      function normalizeName(value) {
        if (!value) return "";
        let text = String(value).trim();
        if (text.includes(",")) {
          const parts = text.split(",");
          const last = parts[0].trim();
          const rest = parts.slice(1).join(" ").trim();
          if (rest) text = rest + " " + last;
        }
        text = text.replace(/[^a-zA-Z\s]/g, " ");
        return text.replace(/\s+/g, " ").trim().toLowerCase();
      }

      function parseDate(value) {
        if (!value) return null;
        if (value instanceof Date) {
          return new Date(value.getFullYear(), value.getMonth(), value.getDate());
        }
        if (typeof value === "number") {
          const parsed = XLSX.SSF.parse_date_code(value);
          if (parsed && parsed.y && parsed.m && parsed.d) {
            return new Date(parsed.y, parsed.m - 1, parsed.d);
          }
        }
        if (typeof value === "string") {
          const cleaned = value.trim();
          if (!cleaned) return null;
          const parsed = new Date(cleaned);
          if (!isNaN(parsed)) {
            return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
          }
        }
        return null;
      }

      function formatDate(value) {
        if (!value) return "";
        const year = value.getFullYear();
        const month = String(value.getMonth() + 1).padStart(2, "0");
        const day = String(value.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      function formatDisplayDate(value) {
        if (!value) return "";
        return value.toLocaleDateString("en-US");
      }

      function setStatus(el, text, status) {
        el.textContent = text;
        el.className = "status" + (status ? " " + status : "");
      }

      async function apiRequestJson(url, options) {
        const opts = options || {};
        const headers = Object.assign({ "Content-Type": "application/json" }, opts.headers || {});
        const res = await fetch(url, Object.assign({}, opts, { headers }));
        if (!res.ok) {
          const message = await res.text();
          throw new Error(message || `Request failed (${res.status})`);
        }
        if (res.status === 204) return null;
        return res.json();
      }

      async function apiRequestJson(url, options) {
        const opts = options || {};
        const headers = Object.assign({ "Content-Type": "application/json" }, opts.headers || {});
        const res = await fetch(url, Object.assign({}, opts, { headers }));
        if (!res.ok) {
          const message = await res.text();
          throw new Error(message || `Request failed (${res.status})`);
        }
        if (res.status === 204) return null;
        return res.json();
      }

      function readWorkbook(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const workbook = XLSX.read(e.target.result, { type: "array", cellDates: true });
              resolve(workbook);
            } catch (err) {
              reject(err);
            }
          };
          reader.onerror = () => reject(reader.error);
          reader.readAsArrayBuffer(file);
        });
      }

      function sheetToRows(sheet) {
        return XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true, defval: "" });
      }

      function employeeKeyFor(assignment) {
        return assignment.workerIdKey ? `id:${assignment.workerIdKey}` : `name:${assignment.nameNorm}`;
      }

      function findAssignmentsSheet(workbook) {
        const sheetNames = workbook.SheetNames;
        for (const name of sheetNames) {
          const sheet = workbook.Sheets[name];
          const rows = sheetToRows(sheet).slice(0, 50);
          const headerResult = findHeaderRow(rows, ["resourceName", "serviceLine"]);
          if (headerResult) {
            return { sheet, sheetName: name, headerResult };
          }
        }
        return null;
      }

      function findHeaderRow(rows, requiredKeys) {
        for (let r = 0; r < rows.length; r++) {
          const row = rows[r];
          const colIndexByKey = {};
          row.forEach((cell, c) => {
            const key = HEADER_LOOKUP[normalizeHeader(cell)];
            if (key && colIndexByKey[key] === undefined) {
              colIndexByKey[key] = c;
            }
          });
          const hasAll = requiredKeys.every((key) => colIndexByKey[key] !== undefined);
          if (hasAll) {
            return { rowIndex: r, colIndexByKey };
          }
        }
        return null;
      }

      function looksLikeName(value) {
        if (!value) return false;
        const text = String(value).trim();
        if (text.length < 3) return false;
        const words = text.split(/\s+/);
        if (text.includes(",")) return true;
        return words.length >= 2 && words.length <= 4;
      }

      function looksLikeServiceLine(value) {
        if (!value) return false;
        const text = String(value).toLowerCase();
        const keywords = ["aml", "audit", "testing", "compliance", "regulatory", "risk", "internal", "non-aml", "non aml"];
        return keywords.some((word) => text.includes(word));
      }

      function guessAssignmentColumns(rows) {
        const sample = rows.slice(0, 50);
        const colStats = {};
        sample.forEach((row) => {
          row.forEach((cell, idx) => {
            if (!colStats[idx]) colStats[idx] = { count: 0, nameScore: 0, serviceScore: 0 };
            if (cell !== "" && cell !== null && cell !== undefined) {
              colStats[idx].count += 1;
              if (looksLikeName(cell)) colStats[idx].nameScore += 1;
              if (looksLikeServiceLine(cell)) colStats[idx].serviceScore += 1;
            }
          });
        });
        const sorted = Object.entries(colStats)
          .sort((a, b) => b[1].count - a[1].count)
          .slice(0, 4);
        let best = null;
        sorted.forEach(([idxA, statsA]) => {
          sorted.forEach(([idxB, statsB]) => {
            if (idxA === idxB) return;
            const score = (statsA.nameScore + statsB.serviceScore);
            if (!best || score > best.score) {
              best = { nameIndex: Number(idxA), serviceIndex: Number(idxB), score };
            }
          });
        });
        if (best && best.score > 0) return best;
        return null;
      }

      async function handleAssignmentsFile(file) {
        try {
          setStatus(els.assignmentsStatus, "Loading...", "warning");
          const workbook = await readWorkbook(file);
          let assignmentData = [];
          let headerRow = null;
          let headerMap = null;
          let usedSheet = null;
          const found = findAssignmentsSheet(workbook);
          if (found) {
            usedSheet = found.sheet;
            headerRow = found.headerResult.rowIndex;
            headerMap = found.headerResult.colIndexByKey;
          } else {
            const firstSheetName = workbook.SheetNames[0];
            usedSheet = workbook.Sheets[firstSheetName];
            const rows = sheetToRows(usedSheet);
            const guess = guessAssignmentColumns(rows);
            if (!guess) {
              throw new Error("Unable to detect Assignment headers or columns.");
            }
            headerRow = 0;
            headerMap = {
              resourceName: guess.nameIndex,
              serviceLine: guess.serviceIndex
            };
            setStatus(els.assignmentsStatus, "Heuristic match used", "warning");
          }

          const rows = sheetToRows(usedSheet);
          for (let r = headerRow + 1; r < rows.length; r++) {
            const row = rows[r];
            const name = row[headerMap.resourceName];
            const serviceLine = row[headerMap.serviceLine];
            if (!name && !serviceLine) continue;
            const workerIdRaw = headerMap.workerId !== undefined ? row[headerMap.workerId] : "";
            const assignment = {
              id: `A${assignmentData.length + 1}`,
              name: String(name || "").trim(),
              serviceLine: String(serviceLine || "").trim(),
              serviceLineNorm: normalizeText(serviceLine),
              workerIdRaw: String(workerIdRaw || "").trim(),
              workerIdKey: normalizeWorkerId(workerIdRaw),
              nameNorm: normalizeName(name)
            };
            if (!assignment.name || !assignment.serviceLine) continue;
            assignment.employeeKey = employeeKeyFor(assignment);
            assignmentData.push(assignment);
          }

          if (assignmentData.length === 0) {
            throw new Error("No assignment rows found.");
          }

          state.assignments = assignmentData;
          state.assignmentsById = new Map();
          state.assignmentsByWorkerId = new Map();
          state.assignmentsByName = new Map();

          assignmentData.forEach((assignment) => {
            state.assignmentsById.set(assignment.id, assignment);
            if (assignment.workerIdKey) {
              if (!state.assignmentsByWorkerId.has(assignment.workerIdKey)) {
                state.assignmentsByWorkerId.set(assignment.workerIdKey, []);
              }
              state.assignmentsByWorkerId.get(assignment.workerIdKey).push(assignment);
            }
            if (assignment.nameNorm) {
              if (!state.assignmentsByName.has(assignment.nameNorm)) {
                state.assignmentsByName.set(assignment.nameNorm, []);
              }
              state.assignmentsByName.get(assignment.nameNorm).push(assignment);
            }
          });

          markAmbiguousAssignments();
          setStatus(els.assignmentsStatus, `Loaded ${assignmentData.length} assignments`, "success");
          recompute();
        } catch (err) {
          setStatus(els.assignmentsStatus, err.message || "Failed to load", "warning");
        }
      }

      function markAmbiguousAssignments() {
        const duplicates = new Set();
        state.assignmentsByName.forEach((list, key) => {
          if (list.length > 1) duplicates.add(key);
        });
        state.assignments.forEach((assignment) => {
          assignment.ambiguousName = duplicates.has(assignment.nameNorm);
        });
      }

      function findTimeDetailSheet(workbook) {
        for (const name of workbook.SheetNames) {
          const sheet = workbook.Sheets[name];
          const rows = sheetToRows(sheet).slice(0, 50);
          for (let r = 0; r < rows.length; r++) {
            const row = rows[r];
            const colIndexByKey = {};
            row.forEach((cell, c) => {
              const key = HEADER_LOOKUP[normalizeHeader(cell)];
              if (key && colIndexByKey[key] === undefined) {
                colIndexByKey[key] = c;
              }
            });
            const hasTask = colIndexByKey.taskDesc !== undefined;
            const hasDate = colIndexByKey.date !== undefined;
            const hasWorker = colIndexByKey.workerId !== undefined || colIndexByKey.resourceName !== undefined;
            if (hasTask && hasDate && hasWorker) {
              return { sheet, sheetName: name, headerRow: r, colIndexByKey };
            }
          }
        }
        return null;
      }

      async function handleTimeDetailFile(file) {
        try {
          setStatus(els.timeDetailStatus, "Loading...", "warning");
          const workbook = await readWorkbook(file);
          const found = findTimeDetailSheet(workbook);
          if (!found) {
            throw new Error("Unable to locate the Time Detail header row.");
          }
          const rows = sheetToRows(found.sheet);
          const header = found.colIndexByKey;
          const entries = [];

          for (let r = found.headerRow + 1; r < rows.length; r++) {
            const row = rows[r];
            const taskDesc = row[header.taskDesc];
            const dateVal = row[header.date];
            const workerIdRaw = header.workerId !== undefined ? row[header.workerId] : "";
            const workerName = header.resourceName !== undefined ? row[header.resourceName] : "";
            if (!taskDesc && !workerIdRaw && !workerName) continue;
            const date = parseDate(dateVal);
            const entry = {
              rowIndex: r + 1,
              date,
              workerIdRaw: String(workerIdRaw || "").trim(),
              workerIdKey: normalizeWorkerId(workerIdRaw),
              workerName: String(workerName || "").trim(),
              workerNameNorm: normalizeName(workerName),
              taskDesc: String(taskDesc || "").trim(),
              taskDescNorm: normalizeText(taskDesc),
              memo: header.memo !== undefined ? String(row[header.memo] || "").trim() : "",
              hours: header.hours !== undefined ? row[header.hours] : "",
              project: header.project !== undefined ? String(row[header.project] || "").trim() : ""
            };
            if (!entry.taskDesc && !entry.workerName && !entry.workerIdRaw) continue;
            entries.push(entry);
          }

          if (entries.length === 0) {
            throw new Error("No time detail rows found.");
          }

          state.timeEntries = entries;
          setStatus(els.timeDetailStatus, `Loaded ${entries.length} time rows`, "success");
          recompute();
        } catch (err) {
          setStatus(els.timeDetailStatus, err.message || "Failed to load", "warning");
        }
      }

      function getDateRange() {
        const start = els.startDate.value ? new Date(els.startDate.value) : null;
        const end = els.endDate.value ? new Date(els.endDate.value) : null;
        return { start, end };
      }

      function inExclusiveRange(date, start, end) {
        if (!date || !start || !end) return false;
        return date > start && date < end;
      }

      function matchAssignmentForEntry(entry) {
        if (entry.workerIdKey && state.assignmentsByWorkerId.has(entry.workerIdKey)) {
          const matches = state.assignmentsByWorkerId.get(entry.workerIdKey);
          return { assignment: matches[0], ambiguous: matches.length > 1, reason: "Duplicate Worker ID" };
        }
        if (entry.workerNameNorm && state.assignmentsByName.has(entry.workerNameNorm)) {
          const matches = state.assignmentsByName.get(entry.workerNameNorm);
          return { assignment: matches[0], ambiguous: matches.length > 1, reason: "Ambiguous name match" };
        }
        return { assignment: null, ambiguous: false, reason: "" };
      }

      function computeSummaries() {
        const { start, end } = getDateRange();
        if (!start || !end) return null;
        const summariesById = new Map();
        const unmatched = [];
        const ambiguousEntries = [];
        const entriesInRange = state.timeEntries.filter((entry) => inExclusiveRange(entry.date, start, end));

        function getSummary(assignment) {
          if (!summariesById.has(assignment.id)) {
            summariesById.set(assignment.id, {
              assignment,
              entryCount: 0,
              incorrectEntries: [],
              missingMemos: [],
              ambiguous: false
            });
          }
          return summariesById.get(assignment.id);
        }

        entriesInRange.forEach((entry) => {
          const match = matchAssignmentForEntry(entry);
          if (!match.assignment) {
            unmatched.push(entry);
            return;
          }
          const summary = getSummary(match.assignment);
          summary.entryCount += 1;
          if (match.ambiguous) {
            summary.ambiguous = true;
            ambiguousEntries.push({ entry, reason: match.reason });
          }
          const expected = match.assignment.serviceLineNorm;
          const actual = entry.taskDescNorm;
          if (expected && actual && expected !== actual) {
            entry.mismatchReason = "Task Desc does not match Service Line";
            summary.incorrectEntries.push(entry);
          } else if (!expected || !actual) {
            entry.mismatchReason = "Missing Service Line or Task Desc";
            summary.incorrectEntries.push(entry);
          }
          if (!entry.memo || entry.memo.trim() === "") {
            summary.missingMemos.push(entry);
          }
        });

        return {
          summariesById,
          entriesInRange,
          unmatched,
          ambiguousEntries,
          start,
          end
        };
      }

      function recompute() {
        if (state.assignments.length === 0 || state.timeEntries.length === 0) {
          els.packageSummary.innerHTML = "";
          setStatus(els.packageStatus, "Not Ready", "");
          els.adminSummary.innerHTML = "";
          els.adminOutput.innerHTML = "";
          return;
        }
      state.summaries = computeSummaries();
      updatePackageSummary();
      updateAdminOutput();
      updateAttestationStatusFromEvents(state.attestationStatusRows);
    }

      function updatePackageSummary() {
        if (!state.summaries) {
          els.packageSummary.innerHTML = "";
          setStatus(els.packageStatus, "Not Ready", "");
          return;
        }
        let incorrectTotal = 0;
        let memoTotal = 0;
        state.summaries.summariesById.forEach((summary) => {
          incorrectTotal += summary.incorrectEntries.length;
          memoTotal += summary.missingMemos.length;
        });
        els.packageSummary.innerHTML = `
          <span class="pill"><strong>Employees:</strong> ${state.assignments.length}</span>
          <span class="pill"><strong>Entries in Range:</strong> ${state.summaries.entriesInRange.length}</span>
          <span class="pill"><strong>Incorrect Entries:</strong> ${incorrectTotal}</span>
          <span class="pill"><strong>Missing Memos:</strong> ${memoTotal}</span>
        `;
        setStatus(els.packageStatus, "Ready to Publish", "success");
      }

      function buildEmployeePackage() {
        if (!state.summaries) return null;
        const { summariesById, start, end } = state.summaries;
        state.packageId = `CroweRecon_${Date.now()}`;
        const summaryMap = {};
        state.assignments.forEach((assignment) => {
          const summary = summariesById.get(assignment.id);
          summaryMap[assignment.id] = {
            entryCount: summary ? summary.entryCount : 0,
            incorrectEntries: summary ? summary.incorrectEntries.map(stripEntry) : [],
            missingMemos: summary ? summary.missingMemos.map(stripEntry) : [],
            ambiguous: summary ? summary.ambiguous : assignment.ambiguousName
          };
        });
        return {
          version: "1.0",
          packageId: state.packageId,
          generatedAt: new Date().toISOString(),
          period: {
            start: formatDate(start),
            end: formatDate(end)
          },
          assignments: state.assignments.map((assignment) => ({
            id: assignment.id,
            name: assignment.name,
            workerIdRaw: assignment.workerIdRaw,
            serviceLine: assignment.serviceLine,
            nameNorm: assignment.nameNorm,
            employeeKey: assignment.employeeKey,
            ambiguousName: assignment.ambiguousName
          })),
          summaries: summaryMap
        };
      }

      function stripEntry(entry) {
        return {
          date: entry.date ? entry.date.toISOString() : "",
          taskDesc: entry.taskDesc || "",
          project: entry.project || "",
          hours: entry.hours || "",
          memo: entry.memo || ""
        };
      }

    async function publishEmployeePackage() {
      const pkg = buildEmployeePackage();
      if (!pkg) return;
      setStatus(els.packageStatus, "Publishing...", "warning");
      try {
        const data = await apiRequestJson("/api/packages", {
          method: "POST",
          body: JSON.stringify(pkg)
        });
        state.packageId = data && data.packageId ? data.packageId : pkg.packageId;
        setStatus(els.packageStatus, "Published", "success");
        await refreshAttestationStatus();
      } catch (err) {
        setStatus(els.packageStatus, err.message || "Publish failed", "warning");
      }
    }

      function updateAdminOutput() {
        if (!state.summaries) return;
        const { summariesById, entriesInRange, unmatched, ambiguousEntries } = state.summaries;
        const summaries = Array.from(summariesById.values());
        const incorrectSummaries = summaries.filter((summary) => summary.incorrectEntries.length > 0);

        els.adminSummary.innerHTML = `
          <span class="pill"><strong>Total Entries:</strong> ${entriesInRange.length}</span>
          <span class="pill"><strong>Employees w/ Incorrect:</strong> ${incorrectSummaries.length}</span>
          <span class="pill"><strong>Unmatched Entries:</strong> ${unmatched.length}</span>
          <span class="pill"><strong>Ambiguous Matches:</strong> ${ambiguousEntries.length}</span>
        `;

        let html = "";
        if (incorrectSummaries.length === 0) {
          html += "<p class='success'>No incorrect entries detected for this range.</p>";
        } else {
          html += "<h3>Employees with Incorrect Entries</h3>";
          html += `
            <table>
              <thead>
                <tr>
                  <th>Employee</th>
                  <th>Worker ID</th>
                  <th>Expected Service Line</th>
                  <th>Incorrect Entries</th>
                  <th>Missing Memos</th>
                </tr>
              </thead>
              <tbody>
                ${incorrectSummaries.map((summary) => `
                  <tr>
                    <td>${summary.assignment.name}</td>
                    <td>${summary.assignment.workerIdRaw || ""}</td>
                    <td>${summary.assignment.serviceLine}</td>
                    <td>${summary.incorrectEntries.length}</td>
                    <td>${summary.missingMemos.length}</td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          `;
        }

        if (unmatched.length > 0) {
          html += `<h3>Unmatched Time Entries</h3>${renderEntriesTable(unmatched)}`;
        }

        if (ambiguousEntries.length > 0) {
          html += `<h3>Ambiguous Matches</h3>${renderAmbiguousTable(ambiguousEntries)}`;
        }

        els.adminOutput.innerHTML = html;
      }

      function renderEntriesTable(entries) {
        if (!entries || entries.length === 0) {
          return "<p class='muted'>No entries.</p>";
        }
        const rows = entries.map((entry) => `
          <tr>
            <td>${formatDisplayDate(entry.date)}</td>
            <td>${entry.taskDesc || ""}</td>
            <td>${entry.project || ""}</td>
            <td>${entry.hours || ""}</td>
            <td>${entry.memo || ""}</td>
          </tr>
        `).join("");
        return `
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Task Desc</th>
                <th>Project</th>
                <th>Hours</th>
                <th>Memo</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        `;
      }

      function renderAmbiguousTable(entries) {
        const rows = entries.map(({ entry, reason }) => `
          <tr>
            <td>${formatDisplayDate(entry.date)}</td>
            <td>${entry.workerName || ""}</td>
            <td>${entry.workerIdRaw || ""}</td>
            <td>${entry.taskDesc || ""}</td>
            <td>${reason}</td>
          </tr>
        `).join("");
        return `
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Worker</th>
                <th>Worker ID</th>
                <th>Task Desc</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        `;
      }

      function updateAttestationStatusFromEvents(statusRows) {
        state.statusMap = new Map();
        const statusByKey = new Map();
        (statusRows || []).forEach((row) => {
          statusByKey.set(row.employeeKey, {
            lastViewed: row.lastViewed ? new Date(row.lastViewed) : null,
            lastAttested: row.lastAttested ? new Date(row.lastAttested) : null,
            employeeName: row.employeeName || "",
            workerId: row.workerId || ""
          });
        });

        state.assignments.forEach((assignment) => {
          const eventStatus = statusByKey.get(assignment.employeeKey);
          state.statusMap.set(assignment.employeeKey, {
            assignment,
            lastViewed: eventStatus ? eventStatus.lastViewed : null,
            lastAttested: eventStatus ? eventStatus.lastAttested : null,
            status: "Not Started"
          });
        });

        let completed = 0;
        let inProgress = 0;
        let notStarted = 0;
        state.statusMap.forEach((status) => {
          if (status.lastAttested) {
            status.status = "Completed";
            completed += 1;
          } else if (status.lastViewed) {
            status.status = "In Progress";
            inProgress += 1;
          } else {
            status.status = "Not Started";
            notStarted += 1;
          }
        });

        els.attestationSummary.innerHTML = `
          <span class="pill"><strong>Completed:</strong> ${completed}</span>
          <span class="pill"><strong>In Progress:</strong> ${inProgress}</span>
          <span class="pill"><strong>Not Started:</strong> ${notStarted}</span>
        `;

        els.attestationTable.innerHTML = renderAttestationTable();
      }

      function renderAttestationTable() {
        const rows = Array.from(state.statusMap.values()).map((status) => `
          <tr>
            <td>${status.assignment.name}</td>
            <td>${status.assignment.workerIdRaw || ""}</td>
            <td>${status.status}</td>
            <td>${status.lastViewed ? status.lastViewed.toLocaleString("en-US") : ""}</td>
            <td>${status.lastAttested ? status.lastAttested.toLocaleString("en-US") : ""}</td>
            <td>${status.assignment.ambiguousName ? "Ambiguous Name" : ""}</td>
          </tr>
        `).join("");
        return `
          <table>
            <thead>
              <tr>
                <th>Employee</th>
                <th>Worker ID</th>
                <th>Status</th>
                <th>Last Viewed</th>
                <th>Last Attested</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
        </table>
      `;
    }

      async function refreshAttestationStatus() {
        if (!state.packageId) {
          els.attestationStatus.textContent = "Publish a package first.";
          return;
        }
        els.attestationStatus.textContent = "Refreshing...";
        try {
          const data = await apiRequestJson(`/api/attestations/status?packageId=${encodeURIComponent(state.packageId)}`);
          state.attestationEvents = data.events || [];
          state.attestationStatusRows = data.status || [];
          updateAttestationStatusFromEvents(state.attestationStatusRows);
          els.attestationStatus.textContent = "Updated " + new Date().toLocaleString("en-US");
        } catch (err) {
          els.attestationStatus.textContent = err.message || "Refresh failed";
        }
      }

      function exportAdminReport() {
        if (!state.summaries) return;
        const wb = XLSX.utils.book_new();
        const { summariesById, unmatched, start, end } = state.summaries;
        const dashboard = [[
          "Employee",
          "Worker ID",
          "Expected Service Line",
          "Incorrect Entries",
          "Missing Memos",
          "Attestation Status",
          "Last Viewed",
          "Last Attested"
        ]];

        state.assignments.forEach((assignment) => {
          const summary = summariesById.get(assignment.id);
          const incorrect = summary ? summary.incorrectEntries.length : 0;
          const missing = summary ? summary.missingMemos.length : 0;
          const status = state.statusMap.get(assignment.employeeKey) || {};
          dashboard.push([
            assignment.name,
            assignment.workerIdRaw,
            assignment.serviceLine,
            incorrect,
            missing,
            status.status || "Not Started",
            status.lastViewed ? status.lastViewed.toLocaleString("en-US") : "",
            status.lastAttested ? status.lastAttested.toLocaleString("en-US") : ""
          ]);
        });

        const dashSheet = XLSX.utils.aoa_to_sheet(dashboard);
        XLSX.utils.book_append_sheet(wb, dashSheet, "Dashboard");

        if (state.attestationEvents && state.attestationEvents.length > 0) {
          const logRows = [["Employee", "Worker ID", "Event", "Timestamp", "Details"]];
          state.attestationEvents.forEach((event) => {
            logRows.push([
              event.employeeName || "",
              event.workerId || "",
              event.eventType || "",
              event.createdAt ? new Date(event.createdAt).toLocaleString("en-US") : "",
              event.details || ""
            ]);
          });
          const logSheet = XLSX.utils.aoa_to_sheet(logRows);
          XLSX.utils.book_append_sheet(wb, logSheet, "Attestation Log");
        }

        if (unmatched.length > 0) {
          const unmatchedData = [["Date", "Worker", "Worker ID", "Task Desc", "Project", "Hours", "Memo"]];
          unmatched.forEach((entry) => {
            unmatchedData.push([
              formatDisplayDate(entry.date),
              entry.workerName,
              entry.workerIdRaw,
              entry.taskDesc,
              entry.project,
              entry.hours,
              entry.memo
            ]);
          });
          const unmatchedSheet = XLSX.utils.aoa_to_sheet(unmatchedData);
          XLSX.utils.book_append_sheet(wb, unmatchedSheet, "Unmatched");
        }

        const usedNames = new Set(["Dashboard", "Attestation Log", "Unmatched"]);
        state.assignments.forEach((assignment) => {
          const summary = summariesById.get(assignment.id);
          const incorrect = summary ? summary.incorrectEntries : [];
          const missing = summary ? summary.missingMemos : [];
          const sheetName = makeSheetName(assignment.name, usedNames);
          const rows = [
            ["Employee", assignment.name],
            ["Worker ID", assignment.workerIdRaw],
            ["Expected Service Line", assignment.serviceLine],
            ["Date Range", `${formatDisplayDate(start)} to ${formatDisplayDate(end)} (exclusive)`],
            []
          ];

          if (incorrect.length === 0) {
            rows.push(["You are amazing, you don’t need any reconciliations"]);
          } else {
            rows.push(["Incorrect Entries"]);
            rows.push(["Date", "Task Desc", "Project", "Hours", "Memo"]);
            incorrect.forEach((entry) => {
              rows.push([
                formatDisplayDate(entry.date),
                entry.taskDesc,
                entry.project,
                entry.hours,
                entry.memo
              ]);
            });
          }

          if (missing.length > 0) {
            rows.push([]);
            rows.push(["Entries Missing Memos"]);
            rows.push(["Date", "Task Desc", "Project", "Hours", "Memo"]);
            missing.forEach((entry) => {
              rows.push([
                formatDisplayDate(entry.date),
                entry.taskDesc,
                entry.project,
                entry.hours,
                entry.memo
              ]);
            });
          }

          const sheet = XLSX.utils.aoa_to_sheet(rows);
          XLSX.utils.book_append_sheet(wb, sheet, sheetName);
        });

        const filename = `Crowe_Admin_Recon_${formatDate(start)}_${formatDate(end)}.xlsx`;
        XLSX.writeFile(wb, filename);
      }

      function makeSheetName(name, usedNames) {
        let cleaned = String(name || "Employee").replace(/[\[\]\*\?\/\\:]/g, "").trim();
        if (cleaned.length > 31) cleaned = cleaned.slice(0, 31);
        let finalName = cleaned || "Employee";
        let index = 1;
        while (usedNames.has(finalName)) {
          const suffix = `_${index}`;
          finalName = (cleaned.slice(0, 31 - suffix.length) + suffix);
          index += 1;
        }
        usedNames.add(finalName);
        return finalName;
      }

      function initDateDefaults() {
        const now = new Date();
        const start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const end = new Date(now.getFullYear(), now.getMonth(), 1);
        els.startDate.value = formatDate(start);
        els.endDate.value = formatDate(end);
      }

      function bindDropZone(dropZoneId, handler) {
        const zone = document.getElementById(dropZoneId);
        zone.addEventListener("dragover", (e) => {
          e.preventDefault();
          zone.classList.add("dragover");
        });
        zone.addEventListener("dragleave", () => zone.classList.remove("dragover"));
        zone.addEventListener("drop", (e) => {
          e.preventDefault();
          zone.classList.remove("dragover");
          const file = e.dataTransfer.files[0];
          if (file) handler(file);
        });
      }

      els.assignmentsFile.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) handleAssignmentsFile(file);
      });

      els.timeDetailFile.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) handleTimeDetailFile(file);
      });

      els.startDate.addEventListener("change", () => recompute());
      els.endDate.addEventListener("change", () => recompute());

      els.downloadPackageBtn.addEventListener("click", publishEmployeePackage);
      els.refreshAttestationsBtn.addEventListener("click", refreshAttestationStatus);
      els.exportBtn.addEventListener("click", exportAdminReport);

      els.adminUnlockBtn.addEventListener("click", () => {
        if (els.adminPasscode.value === ADMIN_PASSCODE) {
          els.adminContent.classList.remove("hidden");
          els.adminUnlockStatus.textContent = "Unlocked";
          els.adminUnlockStatus.className = "success";
        } else {
          els.adminUnlockStatus.textContent = "Incorrect passcode";
          els.adminUnlockStatus.className = "alert";
        }
      });

      bindDropZone("admin-assignmentsDrop", handleAssignmentsFile);
      bindDropZone("admin-timeDetailDrop", handleTimeDetailFile);
      initDateDefaults();
    })();

    (function employeeApp() {
      const state = {
        pkg: null,
        assignments: [],
        assignmentsById: new Map(),
        summariesById: new Map(),
        currentEmployeeId: ""
      };

      const els = {
        packageStatus: document.getElementById("emp-packageStatus"),
        packageInfo: document.getElementById("emp-packageInfo"),
        employeeSelect: document.getElementById("emp-employeeSelect"),
        employeeStatus: document.getElementById("emp-employeeStatus"),
        employeeSummary: document.getElementById("emp-employeeSummary"),
        employeeOutput: document.getElementById("emp-employeeOutput"),
        attestationPanel: document.getElementById("emp-attestationPanel"),
        attestationMessage: document.getElementById("emp-attestationMessage"),
        attestationCheck: document.getElementById("emp-attestationCheck"),
        attestationStatus: document.getElementById("emp-attestationStatus"),
        attestBtn: document.getElementById("emp-attestBtn")
      };

      function normalizeName(value) {
        if (!value) return "";
        let text = String(value).trim();
        if (text.includes(",")) {
          const parts = text.split(",");
          const last = parts[0].trim();
          const rest = parts.slice(1).join(" ").trim();
          if (rest) text = rest + " " + last;
        }
        text = text.replace(/[^a-zA-Z\s]/g, " ");
        return text.replace(/\s+/g, " ").trim().toLowerCase();
      }

      function formatDisplayDate(value) {
        if (!value) return "";
        const date = value instanceof Date ? value : new Date(value);
        if (isNaN(date)) return "";
        return date.toLocaleDateString("en-US");
      }

      function setStatus(el, text, status) {
        el.textContent = text;
        el.className = "status" + (status ? " " + status : "");
      }

      async function apiRequestJson(url, options) {
        const opts = options || {};
        const headers = Object.assign({ "Content-Type": "application/json" }, opts.headers || {});
        const res = await fetch(url, Object.assign({}, opts, { headers }));
        if (!res.ok) {
          const message = await res.text();
          throw new Error(message || `Request failed (${res.status})`);
        }
        if (res.status === 204) return null;
        return res.json();
      }

      async function loadLatestPackage() {
        try {
          setStatus(els.packageStatus, "Loading latest package...", "warning");
          const pkg = await apiRequestJson("/api/packages/latest");
          if (!pkg || !pkg.assignments || !pkg.summaries) {
            throw new Error("No package available.");
          }
          state.pkg = pkg;
          state.assignments = pkg.assignments;
          state.assignmentsById = new Map();
          state.summariesById = new Map();
          state.assignments.forEach((assignment) => {
            state.assignmentsById.set(assignment.id, assignment);
          });
          Object.keys(pkg.summaries).forEach((id) => {
            state.summariesById.set(id, pkg.summaries[id]);
          });
          populateEmployeeDropdown();
          updatePackageInfo();
          setStatus(els.packageStatus, "Package Loaded", "success");
          els.employeeStatus.textContent = "Ready";
        } catch (err) {
          setStatus(els.packageStatus, err.message || "Failed to load", "warning");
        }
      }

      function updatePackageInfo() {
        if (!state.pkg) return;
        els.packageInfo.innerHTML = `
          <span class="pill"><strong>Period:</strong> ${state.pkg.period.start} to ${state.pkg.period.end}</span>
          <span class="pill"><strong>Employees:</strong> ${state.assignments.length}</span>
          <span class="pill"><strong>Generated:</strong> ${new Date(state.pkg.generatedAt).toLocaleString("en-US")}</span>
        `;
      }

      function populateEmployeeDropdown() {
        els.employeeSelect.innerHTML = "";
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select your name";
        els.employeeSelect.appendChild(placeholder);

        const sorted = [...state.assignments].sort((a, b) => a.name.localeCompare(b.name));
        sorted.forEach((assignment) => {
          const option = document.createElement("option");
          option.value = assignment.id;
          const suffix = assignment.workerIdRaw ? ` (${assignment.workerIdRaw})` : "";
          const amb = assignment.ambiguousName ? " [Ambiguous]" : "";
          option.textContent = `${assignment.name}${suffix}${amb}`;
          els.employeeSelect.appendChild(option);
        });
      }

      async function postAttestationEvent(eventType, details) {
        if (!state.pkg || !state.currentEmployeeId) return;
        const assignment = state.assignmentsById.get(state.currentEmployeeId);
        if (!assignment) return;
        try {
          await apiRequestJson("/api/attestations", {
            method: "POST",
            body: JSON.stringify({
              packageId: state.pkg.packageId,
              employeeKey: assignment.employeeKey,
              employeeName: assignment.name,
              workerId: assignment.workerIdRaw || "",
              eventType,
              details: details || ""
            })
          });
        } catch (err) {
          els.attestationStatus.textContent = err.message || "Unable to save attestation.";
          els.attestationStatus.className = "alert";
        }
      }

      function updateEmployeeView() {
        const selectedId = els.employeeSelect.value;
        els.employeeSummary.innerHTML = "";
        els.employeeOutput.innerHTML = "";
        els.attestationPanel.classList.add("hidden");
        els.attestationStatus.textContent = "";
        els.attestationStatus.className = "muted";
        els.attestationCheck.checked = false;
        state.currentEmployeeId = selectedId;

        if (!selectedId || !state.pkg) return;
        const assignment = state.assignmentsById.get(selectedId);
        const summary = state.summariesById.get(selectedId) || {
          entryCount: 0,
          incorrectEntries: [],
          missingMemos: [],
          ambiguous: assignment ? assignment.ambiguousName : false
        };

        postAttestationEvent("Viewed", `Range ${state.pkg.period.start} to ${state.pkg.period.end}`);
        els.attestationStatus.textContent = "View saved.";
        els.attestationStatus.className = "muted";

        els.employeeSummary.innerHTML = `
          <span class="pill"><strong>Expected Service Line:</strong> ${assignment.serviceLine || "Unknown"}</span>
          <span class="pill"><strong>Total Entries:</strong> ${summary.entryCount}</span>
          <span class="pill"><strong>Incorrect Entries:</strong> ${summary.incorrectEntries.length}</span>
          <span class="pill"><strong>Missing Memos:</strong> ${summary.missingMemos.length}</span>
          ${summary.ambiguous ? `<span class="pill" style="color: var(--warning);">Ambiguous name match detected</span>` : ""}
        `;

        if (summary.entryCount === 0) {
          els.employeeOutput.innerHTML = "<p class='muted'>No time entries found for this date range.</p>";
        } else if (summary.incorrectEntries.length === 0) {
          els.employeeOutput.innerHTML = "<p class='success'>You are amazing, you don’t need any reconciliations.</p>";
        } else {
          els.employeeOutput.innerHTML = `
            <h3>Incorrect Entries</h3>
            ${renderEntriesTable(summary.incorrectEntries)}
          `;
        }

        if (summary.missingMemos.length > 0) {
          els.employeeOutput.innerHTML += `
            <h3>Entries Missing Memos</h3>
            ${renderEntriesTable(summary.missingMemos)}
          `;
        }

        const attestationText = summary.missingMemos.length > 0
          ? "Please attest that you will return to both systems to update any incorrect hours and add missing memo entries."
          : "Please attest that your time reconciliation is accurate for this period.";
        els.attestationMessage.textContent = attestationText;
        els.attestationPanel.classList.remove("hidden");
      }

      function renderEntriesTable(entries) {
        if (!entries || entries.length === 0) {
          return "<p class='muted'>No entries.</p>";
        }
        const rows = entries.map((entry) => `
          <tr>
            <td>${formatDisplayDate(entry.date)}</td>
            <td>${entry.taskDesc || ""}</td>
            <td>${entry.project || ""}</td>
            <td>${entry.hours || ""}</td>
            <td>${entry.memo || ""}</td>
          </tr>
        `).join("");
        return `
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Task Desc</th>
                <th>Project</th>
                <th>Hours</th>
                <th>Memo</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        `;
      }

      loadLatestPackage();

      els.employeeSelect.addEventListener("change", () => updateEmployeeView());

      els.attestBtn.addEventListener("click", async () => {
        if (!els.attestationCheck.checked) {
          els.attestationStatus.textContent = "Please check the confirmation box first.";
          els.attestationStatus.className = "alert";
          return;
        }
        await postAttestationEvent("Attested", `Range ${state.pkg.period.start} to ${state.pkg.period.end}`);
        els.attestationStatus.textContent = `Attested on ${new Date().toLocaleString("en-US")}`;
        els.attestationStatus.className = "success";
      });
    })();
  </script>
</body>
</html>
